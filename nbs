--[[
  NoteBlock Song API
  by MysticT
  Tweaked by SoniEx2
--]]

-- yield to avoid error
local function yield()
  os.queueEvent("fake")
  os.pullEvent("fake")
end

-- read short integer (16-bit) from file
local function readShort(file)
  return file.read() + file.read() * 256
end

-- read integer (32-bit) from file
local function readInt(file)
  return file.read() + file.read() * 256 + file.read() * 65536 + file.read() * 16777216
end

-- read string from file
local function readString(file)
  local s = ""
  local len = readInt(file)
  for i = 1, len do
    local c = file.read()
    if not c then
      break
    end
    s = s..string.char(c)
  end
  return s
end

-- read nbs file header
local function readNBSHeader(file)
  local header = {}
  header.lenght = readShort(file)
  header.height = readShort(file)
  header.name = readString(file)
  if header.name == "" then
    header.name = "Untitled"
  end
  header.author = readString(file)
  if header.author == "" then
    header.author = "Unknown"
  end
  header.original_author = readString(file)
  if header.original_author == "" then
    header.original_author = "Unknown"
  end
  header.description = readString(file)
  header.tempo = readShort(file) / 100
  header.autosave = file.read()
  header.autosave_duration = file.read()
  header.time_signature = file.read()
  header.minutes_spent = readInt(file)
  header.left_clicks = readInt(file)
  header.right_clicks = readInt(file)
  header.blocks_added = readInt(file)
  header.blocks_removed = readInt(file)
  header.filename = readString(file)
  return header
end

--[[
-- jump to the next tick in the file
local function nextTick(file, tSong)
	local jump = readShort(file)
	for i = 1, jump - 1 do
		table.insert(tSong, {})
	end
	return jump > 0
end

-- read the notes in a tick
local function readTick(file)
	local t = {}
	local jump = readShort(file)
	while jump > 0 do
		local instrument = file.read() + 1
		if instrument > 5 then
			return nil, "Can't convert custom instruments"
		end
		local note = file.read() - 33
		if note < 0 or note > 24 then
			return nil, "Notes must be in Minecraft's 2 octaves"
		end
		if not t[instrument] then
			t[instrument] = {}
		end
		table.insert(t[instrument], note)
		jump = readShort(file)
	end
	return t
end
--]]

local function songCoroutine(song, x)
  local isNote = false
  local i = 1
  local tickCount = 0
  while true do
    if x == "note" and not isNote then
      song, x = coroutine.yield(false, false)
    elseif x == "note" and isNote then
      local count = song.songData:match("^..",i)
      i = i + 2
      count = count:byte() + count:byte(2) * 256
      if count == 0 then
        song, x = coroutine.yield(false, false) -- false = end of tick
        isNote = false
      else
        repeat
          song, x = coroutine.yield(nil, nil) -- nil = empty note
          if x == "tick" then
            break -- non-0 count
          end
          count = count - 1
        until count == 0
        if count == 0 then -- count == 0 is the same as x == "note"
          local inst, key = song.songData:match("^..",i):byte(1,2)
          song, x = coroutine.yield(inst + 1, key - 33)
        end
        i = i + 2 -- needs to be incremented even if we don't read a note
      end
    elseif x == "tick" and isNote then
      repeat -- skip notes
        local count = song.songData:match("^..",i)
        i = i + 2
        count = count:byte() + count:byte(2) * 256
        if count ~= 0 then
          i = i + 2 -- skip next note
        end
      until count == 0
      isNote = false
    elseif x == "tick" and not isNote then
      local count = song.songData:match("^..",i)
      i = i + 2
      count = count:byte() + count:byte(2) * 256
      if count == 0 then
        return false -- no more ticks. next call to getTick()/getNote() errors.
      end
      repeat
        while x == "note" do -- last getTick() should unlock getNote()
          song, x = coroutine.yield(false, false)
        end
        song, x = coroutine.yield(true)
        count = count - 1
      until count == 0
      isNote = true
    end
  end
end

-- API functions

-- save a converted song to a file
function saveSong(tSong, sPath)
  local file = fs.open(sPath, "w")
  if file then
    file.write(textutils.serialize(tSong))
    file.close()
    return true
  end
  return false, "Error opening file "..sPath
end

-- load and convert an .nbs file and save it
function load(sPath, bVerbose)
  local file = fs.open(sPath, "rb")
  if file then
    if bVerbose then
      print("Reading header...")
    end
    local tSong = {}
    local header = readNBSHeader(file)
    tSong.header = header
    tSong.name = header.name
    tSong.author = header.author
    tSong.original_author = header.original_author
    tSong.lenght = header.lenght / header.tempo
    tSong.delay = 1 / header.tempo
    --[[
    if bVerbose then
      print("Reading ticks...")
    end
    while nextTick(file, tSong) do
      local tick, err = readTick(file, tSong)
      if tick then
        table.insert(tSong, tick)
      else
        file.close()
        return nil, err
      end
      yield()
    end
    --]]
    local songData = {}
    local read = file.read
    local insert = table.insert
    while true do
      local b = read()
      yield()
      if not b then break end
      insert(songData,b)
    end
    tSong.songData = string.char(unpack(songData))
    file.close()
    return tSong
  end
  return nil, "Error opening file "..sPath
end

function wrap(song)
  local co = coroutine.wrap(songCoroutine)
  local function nextTick()
    return co(song, "tick")
  end
  local function nextNote()
    return co(song, "note")
  end
  return nextTick, nextNote
end
